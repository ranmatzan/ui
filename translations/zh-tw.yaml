languageName: "繁體中文(ZH-TW)"

##############################
# Really generic things used in multiple places (use sparingly)
##############################
generic:
  actions: 動作
  activate: 已啟用
  as: As
  closeModal: 關閉
  cancel: 取消
  default: 預設
  description: 描述
  disabled: 禁用
  domainName: 域名
  emptyString: ""
  enabled: 啟用
  expires: 到期
  id: ID
  image: 映像
  ipAddress: IP地址
  loading: "讀取中..."
  missing: "*%MISSING%*"
  moreActions: 更多操作
  na: 'N/A'
  name: 名稱
  none: 無
  remove: 移除
  role: 角色
  state: '狀態'
  type: 類型
  unknown: 未知

##############################
# Routes
##############################
accountsPage:
  index:
    header: 帳號
    localLink: 增加帳號
    table:
      state: 狀態
      id: Id
      kind: 類型
      username: 用户名
      name: 名稱
      identity: 身分
      noData: 当前无访问账号
      noName: 無
  new:
    header: 增加帳號
    form:
      username:
        labelText: "登入名稱"
        placeholder: "例如:jsmith"
      password:
        labelText: "密码"
      name:
        labelText: 姓名
        placeholder: "例如:John Smith"
      type:
        labelText: 帳號類型
        dropdownList: 空
      description:
        labelText: 描述
        placeholder: "例如:這是John Smith的帳號"

apiPage:
  header: "環境API Keys"
  actionButton: "增加環境API Key"
  content: |
    環境API Keys與當前環境(<code>{displayName}</code>)關聯，僅能用於管理當前環境的資源。當前環境中具有權限的其他帳號也能夠管理這些API Keys。
  labelText: '端点:'
  table:
    state: 狀態
    name: 名稱
    description: 描述
    publicValue: "Access Key"
    created: 已建立
    noData: "此環境還沒有建立API Keys"
    noName: 無
    noDescription: 無
    noPublicValue: "無public value"
  account:
    header: "帳號API Keys"
    buttonText: "增加帳號API Key"
    content:
      paragraph1: "帳號API Keys與你的用戶帳號關聯，"
      paragraph2: 能够建立、删除及管理您有權限訪問的所有環境。
    table:
      noData: "您還沒有建立任何帳號API Keys。"

auditLogsPage:
  header: 审计日志
  form:
    eventType:
      placeholder: 事件類型
    resourceType:
      placeholder: '資源類型:'
      dropdownPlaceholder: '選擇一種資源類型:'
      dropdownList:
    resourceId:
      placeholder: 资源ID
    requestIp:
      placeholder: 请求IP
    authType:
      placeholder: '驗證類型:'
      dropdownPlaceholder: '選擇驗證類型:'
      dropdownList:
    clearButtonText: 全部清除
    searchButtonText: 搜索
  table:
    time: 時間
    eventType: 事件类型
    description: 描述
    environment: 環境
    resourceTypeId: '资源类型:Id'
    identity: 认证用户
    authIp: 认证类型&IP

authPage:
  root:
    header: 存取控制
  github:
    header:
      text: GitHub存取控制
      accessEnabled: 已啟用
      accessNotEnabled: 未設定
      accessEnabledSubtext:
        wasRestricted: "{appName} 已設定為允許 {wasRestricted} 訪問。"
        wasNotRestricted:
          host: "{appName} 已設定為允許任何GitHub企業用戶訪問。"
          noHost: "{appName} 已設定為允許任何GitHub用户訪問。"
      noAccessConfigured:
        subtext: "{appName} 可以設定為允許一组 GitHub 用户和組織成員訪問。 由於當前未完成此設定，所以任何可以訪問此頁面(或API)的用户都對系統有完全控制權限。"
    authenticated:
      header:
        text: 認證訊息
        enterpriseHostName: '企業主機名稱:'
        clientId:
          text: '客户端ID:'
          helpText: 要修改設定的GitHub應用，請在下方禁用存取控制後重新設定。
      siteAccess:
        accessControl:
          header: 站點存取
          helpText: "設定允許哪些GitHub用户登入並使用 {appName}。 <b>注意:</b> 添加到環境的成員會自動被設定為允許訪問。"
          radio1: 允許任何GitHub用户
          radio2: 限制為特定GitHub用户及組織成員
          isRestricted:
            header: 已授權的用戶及組織
            noIdentity: 無
            saveAuthButton:
              saved: 已儲存
              saving: 儲存中...
              pre: 儲存授權設定
            helpText: "預設情况下，只有用户是環境成員時才允許登入和存取 {appName}。"
            customizeButton: 自訂
      disableAccess:
        header: 危險區域操作;
        warning: '<b class="text-danger">警告:</b> 禁用存取控制將導致任何能夠存取此頁面或API的用户擁有對  {appName}  的完全控制權限。'
        confirmDisable: "確認? 再次點選將關閉存取控制。"
        disable: 關閉存取控制
    notAuthenticated:
      header: "1. 設定GitHub用途"
      ul:
        li1:
          text: '標準版GitHub， <a href="https://github.com/settings/developers" target="_blank">點選此處</a> 在彈出的新視窗中進行用途設定。'
          ul:
            li1: "企業版GitHub，請登入你的帳號，點選Settings，然後點擊Applications進行設定。"
        li2:
          text: '點選 "Register new application" 並填寫表單內容:'
          ul:
            li1: '<b>Application name:</b> <span class="text-muted">任何您喜歡的應用名稱, 例如 My {appName}</span>'
            li2: "<b>Homepage URL: </b> "
            li3: '<b>Application description:</b> <span class="text-muted">Anything you like, optional</span>'
            li4: "<b>Authorization callback URL:</b>"
        li3:
          text: '點選 "Register Application" '
      form:
        headder: "2. 設定 {appName} 使用您的GitHub應用認證"
        subtext: "將新建立GitHub應用的Client ID和Secret複製黏貼到下方的對應輸入欄中"
        clientId:
          labelText: "Client ID"
        clientSecret:
          labelText: "Client Secret"
        ghEnterprise:
          labelText: 使用私有GitHub企業版佈署
        isGHEnterprise:
          labelText: 使用安全連線
        enterpriseHost:
          labelText: 企業主機名稱
          placeholder: '例如:github.example.com'
    testAuth:
      header: "3. 测试并启用验证"
      subtext: 测试以确认你的配置是否正确
      buttonText:
        pre: GitHub验证
        post: 等待GitHub返回
  localAuth:
    header:
      enabled: "本地验证 <b>已启用</b>"
      disabled: '本地验证 <b class="text-warning">未设置</b>'
    subtext:
      enabled:
        text: "{appName} 已设置为允许本地数据库中的账号访问。"
        linkText: 管理账号
      disabled: "{appName} 能够被设置为仅允许 {appName} 本地数据库中定义的用户访问。 当前系统未进行设置， 因此任何访问此页面（或API）的用户都具有系统的完全控制权限。"
    accessEnabled:
      header: 危险区域&trade;
      warning: '<b class="text-danger">警告:</b> 禁用访问控制将导致任何能够访问此页面或API的用户拥有对  {appName}  的完全控制权限。'
      buttonText:
        disable: "确认? 再次点击将关闭访问控制。"
        prompt: 关闭访问控制
    accessDisabled:
      header: "1. 设置管理员用户"
      helpText: "该账户将成为管理员并拥有对 {appName} 的完全控制权限"
      form:
        login:
          labelText: 登录用户名
          placeholder: '例如:jsmith'
        name:
          labelText: 全名
          placeholder: "例如:John Smith"
        password:
          labelText: 密码
        confirmPassword:
          labelText: 确认密码
    accessControl:
      header: 启用访问控制
      helpText: 点击以开启访问控制并登陆
      buttonText:
        pre: 启用本地验证
        post: 启用中...

catalogPage:
  index:
    header: 应用商店
    search:
      placeholder: 搜索....
    certified: 官方认证
    noData:
      singular: 没有符合的应用模板
      plural: 当前目录下没有符合的应用模板

consolePage:
  header: '命令行:'
  closeButton: 关闭

certificatesPage:
  table:
    cn: 域名
    expiresDate: 过期时间
    noCn: 无
  detail:
    header: 证书
    description: 描述
    info:
      labelText: 信息
      valid: 生效时间
      expires: 过期时间
      algorithm: 算法
      issuer: 发布机构
      serialNumber: 序列号
      version: 版本
    domainNames:
      labelText: 域名
  index:
    header: 证书
    linkTo: 添加证书
    table:
      header:
        state: 状态
        name: 名称
        domain: 域名
        expires: 过期时间
      body:
        noData: 当前未添加任何证书
  new:
    header: 添加证书
    form:
      name:
        placeholder: '例如:mydomain.com'
      description:
        placeholder: '例如:mydomain.com的EV证书'

containersPage:
  table:
    ipAddress: IP位置
    primaryHost: 主機
    primaryHostUnknown: 未知
    image: 映像
    stats: 统计
    sparkPrefixCpu: "CPU: "
    sparkPrefixMemory: "記憶體:"
    sparkPrefixNetwork: "網路:"
    sparkPrefixStorage: "存儲:"
    command: 命令
    noCommand: 无
  index:
    header: 容器
    linkTo: 添加容器
    table:
      header:
        state: 状态
        name: 名称
        ip: IP位置
        host: 主機
        image: 映像
        command: 指令
      body:
        noData: 当前未创建任何容器。
  new:
    form:
      name:
        placeholder: '例如:myapp'
      description:
        placeholder: '例如:我的應用'
  containerPage:
    header: '容器:'
    subtext:
      on: 位于
      in: 所属服务
    infoMultiStats:
      tooltip:
        host: 复制到剪贴板
      host: '主机:'
      ip: '容器IP:'
      docker: "Docker ID:"
      image: '镜像:'
      command: '命令:'
      entryPoint: '入口:'
      description: '描述:'
    navTabs:
      labels: '标签:'
      volumes: 卷
      ports: 連接埠
    portsTab:
      table:
        header:
          state: 状态
          ip: IP地址
          public: 主机映射端口
          private: 容器私有端口
          protocol: 协议
        body:
          state: 状态
          ip: IP地址
          public: 主机映射端口
          private: 容器私有端口
          protocol: 协议
          noData: 该容器未暴露任何端口。
    volumesTab:
      table:
        header:
          state: 状态
          mount: 挂载点
          shared: 共享
          writable: 可写
        body:
          state: 状态
          mount: 挂载点
          shared: 共享
          writable: 可写
          error:
            data: '错误:'
            error: 错误
            noData: 该容器未使用卷
          noContainers: 无其他容器

containerSubpod:
  childContainers: 容器
  childSidekicks: 从

# If you change translations here also change the translation in app/utils/constants.js under the FALLBACK_TRANSLATIONS key
# those are present incase we have an error in the app and can not load the translations file
# the error page will at least make a little sense
failWhalePage:
  header: 错误
  reloadButton: |
    <a href="#" onclick="window.location.href = window.location.href; return false;">重新加载</a> 以重试或
  logoutButton: 注销

haPage:
  header:
    enabled: '高可用已 <b class="text-success">启用</b>'
    disabled: 高可用未设置
  haConfigured:
    addHost:
      header: '5. 添加主机'
      subtext: 将下载的脚本拷贝到每一台高可用主机上运行以注册
    hosts:
      header: '主机:'
      waiting: 等待主机加入...
      managementServerCert:
        text: 管理服务器证书
        waiting: 等待主机加入...
    disable:
      header: 危险区域&trade;
      confirm:
        pre: 确认？再次点击将关闭高可用访问
        prompt: 关闭高可用
  haDisabled:
    header: "1. 设置外部数据库"
    subtext: "当前 {appName} 配置为使用内置数据库服务器，高可用部署需要独立的MySQL数据库服务器。"
    externalDatabase:
      ul:
        li1:
          text: 安装外部数据库实例
          ul:
            li1: "可以使用亚马逊RDS或谷歌Cloud SQL等托管解决方案"
            li2: 或者使用自托管或多主机群集
        li2: 点击下方导出数据库按钮导出整个数据库
        li3: 将输入导入到新的外部数据库
      exportDatabase: 导出数据库
      size: 数据库大小
      noLocalDb:
        header: "1. 设置外部数据库"
        subtext: '完成，已使用外部数据库运行。'
    databaseUsage:
      localDb:
        header: '2. 使用新的外部数据库'
        ul:
          li1: '通过以下命令重新运行服务器容器并指向外部数据库'
          isRancher:
            li1: '<a href="http://docs.rancher.com/rancher/installing-rancher/installing-server/#using-an-external-database" target="_blank">查看文档</a> 以获取更多信息。'
      noLocalDb:
        header: '使用新的外部数据库'
        subtext: '完成， <code>{dbHost}</code> 将作为高可用部署的外部数据库。'
    haConfigScript:
      generated:
        header: '3. 生成高可用配置脚本'
        subtext: '完成'
      notGenerated:
        header: '3. 生成高可用配置脚本'
        subtext: '完成配置外部数据库运行后回到此处'
      form:
        clusterSize:
          labelText: 群集规模
          radio1: '<span class="text-bold" style="display: inline-block: width: 120px;">1 台主机:</span> 无高可用'
          radio2: '<span class="text-bold" style="display: inline-block: width: 120px;">3 台主机:</span> 任意 <b>1台</b> 主机发生故障时系统可继续运行'
          radio3: '<span class="text-bold" style="display: inline-block: width: 120px;">5 台主机:</span> 任意 <b>2 台</b> 主机发生故障时系统可继续运行'
        hostRegistration:
          helpText:
            singleCluster: '此处应设置为FQDN，此FQDN解析为高可用主机地址或负载均衡全部高可用主机的负载均衡地址。不要包含<code>/v1</code>或其它路径信息。'
            multiCluster: '此处应设置为FQDN，此FQDN解析为高可用主机地址或负载均衡全部{clusterSize} 台高可用主机的负载均衡地址。不要包含<code>/v1</code>或其它路径信息。'
        certificate:
          labelText: 证书
          radio1: '生成自签名证书'
          radio2:
            noHostUrl: '上传证书'
            hasHostUrl: '上传证书用于 <code>{hostRegistrationUrl}</code>'
        listeningPorts:
          labelText: 监听端口
          table:
            https: HTTPS
            http: HTTP
            swarm: Swarm
            proxyToHttps: '<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank">PROXY</a> to HTTPS'
            proxyToHttp: '<a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt" target="_blank">PROXY</a> to HTTP'
            redis: Redis
            zookeeperClient: ZooKeeper客户端
            zookeeperQuorum: Zookeeper仲裁
            zookeeperLeader: ZooKeeper Leader
      configScriptButton:
        pre: 生成配置脚本
        post: '生成中...'
      downloadScript:
        downloaded:
          header: '4. 下载脚本'
          subtext: '完成，请查看下载目录。'
        notDownloaded:
          header: '4. 下载脚本'
          subtext: '点击下方按钮以下载命令行脚本。'
          alert: |
              脚本生成新的加密秘钥用于高可用主机间的通讯，请确保相关信息的安全。
              每次您下载配置脚本时将生成新的秘钥，为确保高可用正常工作，所有的主机必须拥有相同的密钥。
          buttonText: 下载配置脚本
          generateScript: '生成步骤3中的脚本'

helpPage:
  header: 常用連結及訊息
  banner: 公告
  releaseText: '釋出时间:'
  environment:
    header: 什么是環境？
    content: |
      <p>{appName} 支持将资源分组归属到多个环境中。每个环境具有自己独立的基础架构资源及服务，并由一个或多个用户、团队或组织所管理。</p>
        <p>例如，您可以创建独立的“开发”、“测试”及“生产”环境以确保环境之间的安全隔离，将“开发”环境的访问权限赋予全部人员，但限制“生产”环境的访问权限给一个小的团队。</p>
    manageLink: 管理环境
  host:
    header: 什么是主机？
    content: |
      在添加第一个服务或容器之前，必须至少添加一台支持Docker{minVersion} 或以上版本的Linux主机，该主机需要能够通过HTTP方式访问{appName} 服务器。{appName} 支持添加多种形式的Linux主机，
        包括由任何公有云、私有云或裸机方式提供的虚拟机或物理机。
    contentLink: 了解更多
    addHostLink: 添加主机
  stacks:
    header: 什么是应用栈和服务？
    content:
      paragraph1: |
        简单而言，服务是一组由相同docker镜像创建的容器，Rancher服务扩展了Docker的“link”概念以利用{appName}的轻量级分布式DNS服务用于服务发现。服务可以单独添加或通过应用商店部署。
      paragraph2: '服务也能够利用其他{appName}内置服务，如负载均衡、健康监控、升级支持以及高可用。'
      #' fixes syntax highlighting so i dont go crazy
      link: 了解更多
    addServiceLink: 管理服务
    addCatalogLink: 通过应用商店添加服务
    noHosts: 当前环境未添加主机。请在添加服务前先添加主机。
    manageServiceLink: 管理服务
  issues:
    header:
      text: 问题及文档
      tagline: 发现问题？
      fileBug: 提交Bug
    content:
      paragraph1: |
        {appName}是一个开源的软件平台，实现了一个在生产环境中运行容器的专用基础设施。Docker容器，作为一个越来越受欢迎的应用程序工作负载，对于基础设施服务，包括网络、存储、负载均衡器、安全、服务发现及资源管理等各方面提出了新的需求。
      graphic1:
        text: 发现bug？
        link: 在GitHub上提出问题
      graphic2:
        text: 更多有用信息
        link: |
          <a href="{docsLink}" target="_blank">关于{appName} 使用请参考官方文档</a>
          <br/>或 <a href="{companyLink}/learn/" target="_blank">观看我们的快速上手教程</a>
      graphic3:
        text: 需要故障诊断协助？
        link: 参考我们的常见问题解答
  forums:
    header: 论坛信息
    tagline: 加入讨论
    buttonText: 进入论坛
    annoucements:
      header: 公告
      annouceText: |
        <strong>最新版本:</strong><a href="{latestLink}" target="_blank">{latestTitle}</a>
      releaseText: |
    general:
      header: 综合
      buttonText: 查看更多综合讨论
    rancherOs:
      header: RancherOS
      buttonText: 查看更多RancherOS讨论
    rancher:
      header: Rancher
      buttonText: 查看更多Rancher讨论
    convoy:
      header: Convoy
      buttonText: 查看更多Convoy讨论
  commercial:
    header: 商业支持
    content: |
      Rancher Labs提供对{appName}的商业化的企业级支持服务，包括24x7技术支持团队、漏洞优先修复等。此外我们还提供实施、集成及顾问服务以满足不同组织部署及扩展{appName}的需求。关于上述服务的详细信息，请联系我们的销售团队<a href="mailto:sales@rancher.com">sales@rancher.com</a>。

hostsPage:
  addContainer: 添加容器
  index:
    header: 主机
    addHost: 添加主机
    tooltip:
      listView: 列表
      groupedView: 分组
    columns:
      emptyMessage: 当前没有主机或容器
  new:
    header:
      linkTo: "主机: "
      text: 添加主机
    manageLink: 管理docker-machine驱动
    form:
      name:
        placeholder: 例如:host01
  hostPage:
    header:
      linkTo: '主机:'
    addContainer:
      linkTo: 添加容器
    infoMultiStats:
      ip: 'IP:'
      cpu: 'CPU:'
      memory: '内存:'
      storage: '存储:'
      provider:
        labelText: '提供者:'
        noHost: 自定义
      kernel: '内核:'
      docker: 'Docker:'
      os: '操作系统:'
      description: '描述:'
    navTabs:
      containers: 容器
      ports: 端口
      labels: 标签
      storage: 存储
    containersTab:
      table:
        header:
          state: 状态
          name: 名称
          ip: IP地址
          image: 镜像(命令)
          stats: 统计
        body:
          noData: 主机当前未运行任何容器
    portsTab:
      table:
        header:
          ip: IP地址
          port: 端口
          service: 服务
          container: 容器
        body:
          noData: 主机当前未映射任何端口
    storageTab:
      table:
        header:
          state: 状态
          hostPath: 主机路径
          mounts: 挂载
        body:
          noData: 主机未使用任何数据卷

k8sTab:
  kubectl:
    header: kubectl
    stepOne:
      generateConfigText: |
        要在你的工作站使用 <a href="http://kubernetes.io/docs/getting-started-guides/docker/#download-kubectl" target="_blank">kubectl</a> (v1.2及以上) ，单击按钮生成API Key及配置文件:
      generateButton: 生成配置
    stepTwo:
      progress: 生成中...
    stepThree:
      helpText: |
        将设置保存到 <code>~/.kube/config</code>:
      downloadText: |
        然后 <a href="http://kubernetes.io/docs/getting-started-guides/docker/#download-kubectl" target="_blank">下载</a> (如果需要) 并运行 <code>kubectl</code>
    shell:
      helpText: |
        或通过下面的命令行直接运行 <code>kubectl</code> 命令:
  multistat:
    header:
      type: '类型:'
      cluster: 'Cluster IP:'
      balancer: 'Balancer IP:'
      session: '会话关联:'
      external: '外部IPs:'
      selectors: 'Selectors'
  navTabs:
    pods: Pods
    labels: Labels
    ports: 端口
  namespace:
    pods:
      index:
        header: Pods
        linkTo: 添加Pod
        table:
          header:
            status: 状态
            containers: 容器
            host: 主机IP
            pod: Pod IP
          body:
            noData: 当前未创建任何Pod
      pod:
        header:
          linkTo: 'Pod:'
        type:
          header: '类型:'
        navTabs:
          containers: 容器
    rcs:
      index:
        header: RCs
        linkTo: 添加RC
        table:
          header:
            replicas: 副本
            selectors: Selectors
            containers: 容器
          body:
            noData: "当前未创建任何Replication Controller"
      rc:
        header: 'RC:'
        navTabs:
          pods: Pods
          labels: Labels
          ports: 端口
    services:
      header: 服务
      linkTo: 添加Service
      table:
        header:
          cluster: "Cluster IP"
          pods: Pods
          ports: 端口
          selectors: Selectors
        body:
          noData: 当前未创建任何Service
      service:
        index:
          header: '服务:'
  namespaces:
    header: 命名空间
    linkTo: 添加命名空间
    table:
      body:
        noData: 当前未创建任何命名空间

loginPage:
  greeting: "你好！<br>欢迎使用 {appName}"
  githubMessage: "{appName} 使用GitHub管理账号和团队。点击以下按钮以登录，我们将仅使用基本的GitHub账号信息。"

machinePage:
  header: 主机驱动
  inactive: 未激活
  download: 下载驱动包
  upgradeAvailable: 有可用更新
  upgrading: 更新中
  activating: 激活中
  viewUi: 查看UI
  subtext: "此处可添加额外的 <code>docker-machine</code> 驱动并在添加主机界面使用。"
  add: 添加主机驱动
  builtin: 内置
  other: 其他
  table:
    header:
      state: 状态
      name: 名称
      url: 驱动URL
      uiUrl: UI URL
      checksum: 校验和
    noData: 没有主机驱动

mesosPage:
  header: 概览
  actionLink: 打开Mesos UI

  banner:
    header: 群集
    content: |
      当前有 {hosts, plural,
        =1 {# 台活动主机}
        other {# 台活动主机}
      } 在Mesos群集中
    link: 查看或添加主机

  launch:
    header: 启动
    content: 从我们的应用商店中启动框架
    button: 启动框架

  manage:
    header: 管理
    content: "通过Mesos UI管理Mesos"
    button: "Mesos UI"

# If you change translations here also change the translation in app/utils/constants.js under the FALLBACK_TRANSLATIONS key
# those are present in case we have an error in the app and can not load the translations file
# the error page will at least make a little sense
notFoundPage:
  header: 查看的页面不存在！
  linkTo: 回到首页

registriesPage:
  index:
    header: 镜像库
    linkTo: 添加镜像库
    table:
      header:
        state: 状态
        address: 地址
        email: 邮箱
        username: 用户名
        created: 创建时间
      body:
        noData: 当前未创建任何镜像库
  new:
    header: 添加镜像库
    form:
      custom:
        labelText: 地址
        placeholder: '例如:registry.example.com'
      email:
        labelText: 邮箱
        placeholder: '例如:you@example.com'
      username:
        labelText: 用户名
        placeholder: '例如:username'
      password:
        labelText: 密码
        placeholder: '例如:password'

servicePage:
  header: '服务:'
  multistat:
    type: '类型:'
    fqdn: 'FQDN:'
    scale: '数量:'
    image: '镜像:'
    entryPoint: '入口:'
    command: '命令:'
    description: '描述'
    global: 全局
  external:
    externalIp: 外部IPs
    externalHostname: '外部主机名:'
  navTabs:
    ports: 端口
    containers: 容器
    labels: 标签
    links: 链接
  containersTab:
    table:
      header:
        ipAddress: IP地址
        host: 主机
        image: 镜像
        stats: 统计
      body:
        noData: 服务当前没有任何容器
  linksTab:
    header: 链接
    noData: 无链接
  new:
    form:
      name:
        placeholder: '例如:myapp'
      description:
        placeholder: '例如:我的应用'
  newAlias:
    form:
      name:
        placeholder: '例如:myapp'
      description:
        placeholder: '例如:MyApp最新版本'
  newBalancer:
    form:
      name:
        placeholder: '例如:website'
      description:
        placeholder: '例如:mycompany.com的负载均衡'
  portsTab:
    table:
      header:
        port: 端口
        host: 主机IP
      body:
        noData: 服务没有暴露任何端口
    notActive: 端口仅当服务处于活动状态时可见

settingsPage:
  index:
    header: 环境
    linkTo: 添加环境
    subtext: |
      <p> {appName} 支持将资源分组归属到多个<b>环境</b>中。每个环境具有自己独立的基础架构资源及服务，并由一个或多个用户、团队或组织所管理。</p>
      <p>例如，您可以创建独立的“开发”、“测试”及“生产”环境以确保环境之间的安全隔离，将“开发”环境的访问权限赋予全部人员，但限制“生产”环境的访问权限给一个小的团队。</p>

    alert: 当前没有活动环境。在进行其他操作前，需要先创建或激活一个环境。
    table:
      header:
        orchestration: 编排
      body:
        noData: 当前未创建任何环境

stacksPage:
  header:
    all: 全部应用
    user: 用户应用
    system: 系统应用
  actionButton: 添加应用栈
  sort:
    label: 排序
    state: 状态
    name: 名称
  noSystemStacks: 当前没有系统应用
  new:
    header: 添加应用栈
    composeLabel: '可选:导入Compose'
    form:
      name:
        placeholder: '例如:myapp'
      description:
        placeholder: '例如:我的应用'
      dockerCompose:
        label: '可选:docker-compose.yml'
        placeholder: docker-compose.yml文件的内容
      rancherCompose:
        label: '可选:rancher-compose.yml'
        placeholder: rancher-compose.yml文件的内容
      startOnCreate:
        label: 创建后启动服务

storagePoolsPage:
  index:
    header: 存储池
    noData: 无存储池
  newVolume:
    header: 添加卷
    form:
      driverOptions: 驱动选项
      addActionLabel: 添加选项

swarmPage:
  projects:
    index:
      header: 项目
      linkTo: 添加项目
      table:
        header:
          services: 服务
        body:
          noData: 当前没有任何项目
    new:
      header: 添加项目
      form:
        name:
          placeholder: '例如:myapp'
        description:
          placeholder: '例如:MyApp Project'
        variables:
          addActionLabel: 添加变量替换
          keyLabel: 变量
          keyPlaceholder: '例如:foo'
          valuePlaceholder: '例如:bar'
        dockerCompose:
          labelText: dcoker-compose.yml
          placeholder: 粘贴docker-compose.yml文件的内容
    project:
      linkTo: '项目:'
      table:
        header:
          ports: 端口
          containers: 容器
        body:
          noData: 当前项目不包含任何服务
  services:
    header: 服务
    table:
      header:
        ports: 端口
        containers: 容器
      body:
        noData: 当前没有任何服务

processesPage:
  indexPage:
    header: 进程
    tabNav:
      running: 运行中
      all: 全部
    form:
      resourceType: '选择资源类型:'
      resourceId:
        placeholder: 资源ID
      processName:
        placeholder: 进程名
      clear: 清除
      search: 搜索
    table:
      header:
        id: ID
        processName: 名称
        resource: '资源类型:ID'
        exitReason: 退出原因
        startTime: 开始时间
        endTime: 结束时间
        duration: 持续时间
      noData: 无进程
  processPage:
    header: 设置

virtualMachinePage:
  header: '虚拟机:'
  multistat:
    host: '主机:'
    hostIp: '主机IP:'
    vmIp: '虚拟机IP:'
    image: '镜像:'
    description: '描述:'
  navTabs:
    labels: 标签

virtualMachinesPage:
  header: 虚拟机
  linkTo: 添加虚拟机
  table:
    body:
      noData: 当前没有任何虚拟机

waitingPage:
  hosts:
    header: |
      {expectHosts, plural,
        =1 {添加第一台主机}
        other {添加主机}
      }
    content: |
      至少需要添加 {expectHosts, plural,
        =1 {1台支持}
        other {# 台支持}
      } Docker {minVersion} 或以上版本的Linux主机，该主机需要能够通过HTTP方式访问{appName} 服务器。<br/>
      {appName} 支持添加多种形式的Linux主机，包括由任何公有云、私有云或裸机方式提供的虚拟机或物理机。
    contentLink: 了解更多
    linkToHost: 添加主机
    setup:
      mesos: 设置Mesos
      swarm: 设置Swarm
      kubernetes: 设置Kubernetes

##############################
# Partials
##############################
aliasServicePartial:
  serviceLinks:
    labelText: 服务链接
    linkTo: 查看详情
  links: 链接
  noLinks: 无链接
  description: '描述:'

externalServicePartial:
  extService:
    labelText: 外部服务
    linkTo: 查看详情
  ips: IPs
  hostname: '主机名称:'
  description: '描述:'

hostPartial:
  host:
    addCommon:
      quanity: 数量
      new:
        form:
          name:
            placeholder: '例如:host01'
    addOptions:
      labels: 标签

ldap:
  providerName:
    openldap: OpenLDAP
    ad: 活动目录
  configuredIndication:
    header:
      providerName: "{providerName} 是"
      enabled: 启用
      disabled: 未设置
      subtext:
        enabled: "{appName} 已设置为允许任何 {providerName} 用户访问。"
        disabled: "{appName} 可以设置为仅允许特定的用户和组成员访问。当前系统未设置，任何能够访问此页面或API的用户拥有对  {appName} 的完全控制权限。"
  accessEnabled:
    header: 验证
    subtext: 如需修改服务器配置，请在下方关闭访问控制后重新设置。
    general:
      header: 常规
      server: '服务器:'
      tls: 'TLS:'
      serviceAccount: '服务账号:'
      searchBase: '搜索起点:'
      defaultDomain: '缺省域:'
    users:
      header: 用户
      objectClass: '对象分类:'
      login: '登录字段:'
      name: '名称字段:'
      search: '搜索字段:'
      enabled: '启用字段:'
      disabledBitMask: '禁用位掩码:'
    group:
      header: 组
      objectClass: '对象分类:'
      name: '名称字段:'
      search: '搜索字段:'
    disable:
      header: 危险区域&trade;
      warning: '<b class="text-danger">警告:</b> 禁用访问控制将导致任何能够访问此页面或API的用户拥有对  {appName} 的完全控制权限。'
      confirmDisable:
        pre: 关闭访问控制
        post: "确认? 再次点击将关闭访问控制。"
  accessConfig:
    header: "1. 配置 {providerName} 服务器"
    subtext1: "请输入地址、端口及协议以连接你的 {providerName} 服务器。<code>389</code> 是标准端口（未加密）, <code>636</code> 是加密连接（TLS）端口。"
    subtext2: "{appName} 需要一个对所有登录域有只读权限的服务账号"
    hostName:
      labelText: 主机名或IP地址
    port:
      labelText: 端口
      checkbox: TLS
    serviceUsername:
      labelText: 服务账号用户名
    servicePassword:
      labelText: 服务账号密码
    searchBase:
      helpText: 仅当用户和组位于搜索起点下时才会被使用
      labelText: '搜索起点:'
      placeholder: "例如:dc=mycompany,dc=com"
    defaultDomain:
      helpText: 当用户未指定登录域时使用该域
      labelText: 默认登录域
      placeholder: '例如:mycompany'
  customizeSchema:
    header: "2. 自定义架构"
    helpText: 如果你的活动目录架构(Schema)不是标准格式，可以在这里进行自定义设置。
    users:
      header: 用户
      objectClass:
        labelText: 对象类型
      login:
        labelText: 登录字段
      name:
        labelText: 名称字段
      search:
        labelText: 搜索字段
      status:
        labelText: 状态字段
      disabledBitMask:
        labelText: 禁用状态位掩码
    groups:
      header: 组
      objectClass:
        labelText: 对象分类
      name:
        labelText: 名称字段
      search:
        labelText: 搜索字段
  testAuth:
    header: "3. 测试并启用验证"
    helpText: "通过你的 {providerName} 账号进行验证测试以确认配置是否正确:"
    userName:
      labelText: 你的用户名
    password:
      labelText: 你的密码
    authenticate:
      pre: 验证
      post: "测试中..."

servicePartial:
  noContainers:
    label: 没有容器
    inactive:
      start: 启动

serviceInfoPartial:
  info:
    label: 信息
    linkTo: 查看详情
  image: '镜像:'
  entryPoint: '入口:'
  command: '命令:'
  description: '描述:'
  containers: 容器
  scale: 数量
  noContainers: 无容器
  ports: 端口
  noPublicPorts: 无映射端口
  links: 链接
  noLinks: 无链接
  fqdn: 'FQDN:'
##############################
# Components
##############################
accountRow:

advancedSection:
  hrText: 高级选项

catalogSettings:
  header: 应用商店
  subtext: 应用商店包含应用的rancher-compose模板，用户能够在回答设置问题后简单快速的进行应用部署。
  rancherCertified:
    header:
      rancherCertified: "{appName} 官方认证"
      plCertified: 官方认证
    helpText:
      isRancher: 官方认证模板由Rancher Labs维护并提供支持
      community: 正式维护和支持模板
  community:
    header: 社区贡献
    helpText:
      text: 由社区成员创建并维护的模板
      isRancher: "未经过Rancher Labs认证"
  more:
    header: 更多
    helpText: '此处可以添加自定义的应用商店。每个应用商店必须有唯一的名称和一个支持 <code>git clone</code> 操作的URL。（更多信息请参考此 <a href="https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a" target="_blank">文档</a>）'
    addActionLabel: 添加应用商店
    keyLabel: 名称
    keyPlaceholder: '例如:mycatalog'
    valueLabel: URL
    valuePlaceholder: '例如:https://github.com/mycompany/mycatalog.git'

confirmDelete:
  title: 是否确认要删除
  environmentNote: "注意:此环境内的所有资源都将被永久性的删除，包括通过{appName}创建的主机。"
  protip: "高级技巧:在点击删除时按住 {key} 键以跳过确认操作。"
  confirmAction: 删除
  cancelAction: 取消

containerLogs:
  title: "日志: {instanceName}"
  onlyCombined: "<b>注意:</b> 此容器运行时带有TTY(-t)参数，仅有合并的标准输出和标准错误日志可见"
  combined: 合并日志
  stdout: 标准输出
  stderr: 标准错误
  protip: "高级技巧: 点击查看日志时按住 {key} 键在新窗口中打开"
  scrollTop: 回到顶部
  scrollBottom: 回到底部
  clear: 清除屏幕
  status:
    initializing: 初始化...
    connecting: 连接中...
    connected: 已连接
    disconnected: 已断开
    closed: 已关闭

containerShell:
  protip: "高级技巧: 点击运行命令行时按住 {key} 键在新窗口中打开"
  status:
    initializing: 初始化...
    error: "错误:{error}"
    connecting: 连接中...
    connected: 已连接
    disconnected: 已断开
    closed: 已关闭

copyToClipboard:
  tooltip: 复制到剪贴板
  copied: 已复制

devicePermissions:
  all: 全部
  none: 无
  read: 读
  write: 写
  mknod: Mknod

editAccount:
  title: 编辑账号
  form:
    name:
      label: 名称
      placeholder: "例如:John Smith"
    kind:
      label: 账号类型
      user: 用户
      admin: 管理员
    description:
      label: 描述
      placeholder: "例如:John Smith的账号"
    publicValue:
      label: 登录用户名
    oldPassword:
      label: 当前密码
    newPassword:
      label: 新密码
    confirmPassword:
      label: 确认密码
    identity:
      label: 标识

editAliasService:
  title: 编辑服务别名

editApiKey:
  title:
    justCreated: "API Key已创建"
    editing: "编辑API Key"
    new: "新建API Key"
  publicValue:
    label: "Access Key (用户名)"
  secretValue:
    label: "Secret Key (密码)"
  name:
    placeholder: "例如:App servers"
  description:
    placeholder: "例如:用于app server部署容器"
  saveWarning1: "请保存上面的Key！Secret Key仅显示一次"
  saveWarning2: "如果忘记了Secret Key，您需要重新创建新的API Key"
  noteOptional: "名称和描述均为可选项（有助于记录API Key的用途），您可以直接点击创建按钮。"
  #' fixes syntax highlighting so i dont go crazy

editBalancerService:
  title: 编辑负载均衡
  haproxy:
    label: 配置文件(haproxy.cfg)
    help: |
      '此处可以设置其他 <a href="http://cbonte.github.io/haproxy-dconv/configuration-1.5.html" target="_blank">haproxy.cfg</a>
      配置项，相关内容将被附加到 {appName} 生成的配置中。'
    global:
      label: <code>global</code> section
      prompt: 自定义的global section设置
    defaults:
      label: <code>defaults</code> section
      prompt: 自定义的default section设置

editCertificate:
  title: 编辑证书
  name:
    placeholder: '例如:mydomain.com'
  description:
    placeholder: '例如:mydomain.com的EV证书'
  noteKeyWriteOnly: "注意:Private Key部分为只写(write only)因而显示为空白。更新证书时您需要重新上传Private Key，即便Private Key未发生变化。"

editContainer:
  title:
    vm: 编辑虚拟机
    container: 编辑容器
  name:
    placeholder: '例如:myapp'
  description:
    placeholder: '例如:我的应用'

editExternalService:
  title: 编辑外部服务
  name:
    placeholder: '例如:external-db'
  description:
    placeholder: '例如:外部物理数据库服务器'

editHost:
  title: 编辑主机
  hostname:
    label: 主机名
    help: 由主机操作系统获取
  customName:
    label: 自定义名称
    placeholder: '例如:dev1'
    help: 如果此处未设置，名称将显示为主机名
  description:
    label: 描述
    placeholder: '例如:我的开发主机'
  labels:
    label: 标签

editRegistry:
  title: 编辑镜像库
  address:
    label: 地址
  email:
    label: 邮箱
    placeholder: '例如:you@example.com'
  username:
    label: 用户名
    placeholder: '例如:username'
  password:
    label: 密码
    placeholder: '例如:password'

editService:
  title: 编辑服务

editStack:
  title: 编辑应用栈
  name:
    label: 名称
    placeholder: '例如:myapp'
  description:
    label: 描述
    placeholder: "例如:MyApp Stack"

environmentHeader:
  backLink: '应用栈:'
  outputs: 输出
  add:
    service: 添加服务
    balancer: 添加负载均衡
    external: 添加外部服务
    alias: 添加服务别名
    vm: 添加虚拟机

formatIp:
  noIp: 无
  unknownIp: 未知

formBalancerListeners:
  label: 监听端口
  addAction: 添加端口
  table:
    host: 源IP/端口
    protocol: 协议
    ssl: SSL
    container: 缺省目标端口
    listener: 通道
  host:
    placeholder: "主机侧端口，例如:80"
  protocol:
    placeholder: '选择协议:'
  container:
    placeholder: "容器侧端口，例如:8080"
  listen:
    public: 公开
    internal: 内部

formCommand:
  command:
    label: 命令
    placeholder: "例如:/usr/sbin/httpd -f httpd.conf"
  entryPoint:
    label: 入口
    placeholder: "例如:/bin/sh -c"
  workingDir:
    label: 工作目录
    placeholder: '例如:/myapp'
  user:
    label: 用户
    placeholder: '例如:apache'
  console:
    label: 控制台
    both: '交互 &amp; TTY终端 <span class="text-muted">(-i -t)</span>'
    interactive: '交互 <span class="text-muted">(-i)</span>'
    terminal: 'TTY终端 <span class="text-muted">(-t)</span>'
    none: 无
  autoRestart:
    label: 自动重启
    startOnceFalse: 总是
    startOnceTrue: 从不（仅启动一次）
    no: 从不
    onFailure: '失败时 <span class="text-muted">(非0退出代码)</span> 总是'
    onFailureCondPrefix: 失败时，最多
    onFailureCondSuffix: |
      {limit, plural,
        =1 {次}
        other {次}
      }
    always: 总是
  environment:
    label: 环境变量
    addAction: 添加环境变量
    keyLabel: 变量
    keyPlaceholder: '例如:foo'
    valueLabel: 值
    valuePlaceholder: '例如:bar'

formContainerLinks:
  label: 链接
  addActionLabel: 添加链接
  noContainers: 没有其他容器可链接
  noLinks: 当前容器没有链接
  targetInstance:
    label: 目标容器
    prompt: 选择一个容器...
  name:
    label: 名称
    placeholder: '例如:database'

formDisks:
  addDiskLabel: 添加磁盘
  addRootDiskLabel: 添加根磁盘
  name:
    rootDisk: 根磁盘
    label: 名称
    placeholder: '例如:data'
  size:
    label: 大小
    rootDisk: 由系统镜像决定
  driver:
    label: 驱动

formEngineOpts:
  engineInstallUrl:
    label: Docker安装URL
    placeholder: "例如:http://get.docker.com"
  engineStorageDriver:
    label: 存储驱动
    placeholder: '例如:overlay'
  engineOpts:
    label: 引擎选项
    addActionLabel: 添加引擎选项
    keyPlaceholder: '例如:log-driver'
    valuePlaceholder: '例如:syslog'
  engineLabels:
    label: 引擎标签
    addActionLabel: 添加引擎标签
    keyLabel: 标签
  engineEnv:
    label: 引擎环境
    addActionLabel: 添加环境变量
    keyLabel: 变量
    keyPlaceholder: '例如:HTTP_PROXY'
    valuePlaceholder: "例如:http://your-proxy:8080"
  engineInsecureRegistry:
    label: 非安全镜像库
    addActionLabel: 添加非安全镜像库
    valueLabel: 镜像库域名
    valuePlaceholder: '例如:registry.example.com'
  engineRegistryMirror:
    label: 镜像库镜像
    addActionLabel: 添加镜像库镜像
    valueLabel: 镜像URL
    valuePlaceholder: "例如:https://my-mirror.example.com:5000"

formHealthCheck:
  label: 健康检查
  checkType:
    none: 无
    tcp: TCP连接
    http: HTTP响应2xx/3xx
  request:
    label: HTTP请求
  method:
    prompt: 选择HTTP方法
  path:
    placeholder: '请求路径，例如:/healthcheck'
  version:
    prompt: 选择HTTP版本
  host:
    label: 主机头信息
    placeholder: '例如:www.example.com'
  port:
    label: 端口
    placeholder: '例如:80'
  initializingTimeout:
    label: 初始化超时
    unit: 毫秒
  interval:
    label: 检查间隔
    unit: 毫秒
  timeout:
    label: 检查超时
    unit: 毫秒
  healthyThreshold:
    label: 健康阈值
    unit: 次成功
  unhealthyThreshold:
    label: 不健康阈值
    unit: 次失败
  strategy:
    label: 不健康时
    none: 不进行操作
    recreate: 重新创建
    recreateOnQuorumPrefix: 重新创建，仅当至少
    recreateOnQuorumSuffix: |
      {quorum, plural,
        =1 {个容器}
        other {个容器}
      } 健康时

formKeyValue:
  addAction: 添加键值对
  key:
    label: 键
    placeholder: 键
  separator: "="
  value:
    label: 值
    placeholder: 值
  protip: "高级技巧: 在键(Key)输入栏中粘贴一行或多行的key=value键值对能够批量输入。"

formImage:
  label: 选择镜像
  vm:
    placeholder: 例如:rancher/vm-ubuntu
    dropdownLabel: "{appName} 镜像"
  container:
    placeholder: "例如:ubuntu:trusty"
  pullImage:
    label: 创建前总是拉取镜像

formNameDescription:
  name:
    label: 名称
    placeholder: 名称
  description:
    label: 描述
    placeholder: 描述

formPorts:
  addAction: 端口映射
  public:
    label: "公开主机[IP:]端口"
    placeholderWithIp: "例如:80 或 1.2.3.4:80"
    placeholderWithoutIp: '例如:80'
  private:
    label: 私有容器端口
    placeholder: '例如:8080'
  protocol:
    label: 协议
  noPorts: 当前容器没有端口映射

formScale:
  label: 数量
  global:
    vm: 总是在每台主机上运行一个此虚拟机的实例
    container: 总是在每台主机上运行一个此容器的实例
  regular:
    vm: |
      Run {scale, plural,
        =0 {无虚拟机}
        =1 {1 台虚拟机}
        other {# 台虚拟机}
      }
    container: |
      Run {scale, plural,
        =0 {无容器}
        =1 {1 个容器}
        other {# 个容器}
      }

formSecurity:
  logConfig:
    addActionLabel: 添加选项
    keyPlaceholder: '例如:syslog-facility'
    valuePlaceholder: '例如:daemon'
  privileged: 特权
  fullAccess: 主机完全访问权限
  pidMode: PID模式
  host: 主机
  memoryLimit: 内存限制
  mb: MB
  swapLimit: +Swap限制
  cpuPinning: CPU绑定
  shares: 份额
  capabilities: 内核能力
  helpBlock:
    text: 内核能力能够对容器所拥有的超级用户权限进行更细粒度的控制
    link: 更多信息
  deviceBinding: 设备绑定
  pathHost: 主机内路径
  pathContainer: 容器内路径
  permissions: 权限
  logDriver: 日志驱动
  logOptions: 日志选项

formServiceLinks:
  addAction: 服务链接
  noServices: 无其他服务可链接
  noLinks: 当前服务没有服务链接
  service:
    label: 目标服务
    prompt: 选择服务...
  name:
    label: 名称
    placeholder: '例如:database'

formSslTermination:
  defaultCertificate:
    prompt: 选择证书...
  alternateCertificate:
    prompt: 选择证书...

formTargets:
  title: 目标
  addAction: 添加服务
  hostname:
    label: 请求主机
    placeholder: '例如:svc.com'
  srcPort:
    label: 源端口
    placeholder: '例如:80'
  value:
    label: 目标服务
    prompt: 选择服务...
  path:
    label: 请求路径
    placeholder: "例如: /svc"
  dstPort:
    label: 目标端口
    placeholder: '例如:8080'
  advanced:
    toggle: 显示高级路由选项
    detail: 根据端口、主机头或请求路径等信息将请求转发到不同服务
    help1: |
      如果指定了请求主机和/或路径，HTTP监听端口上的连接将会被路由到基于请求的合适目标。
      例如，您可以使用此设置根据请求主机信息domain1.com 和 domain2.com将访问发送到不同服务，或者将 domain3.com/admin的访问发送到一个不同的服务上。
    help2: |
      匹配的请求将会被发送到目标服务的目标端口。
      如果目标端口未设置，将使用缺省目标端口。如果缺省目标端口也未设置，将使用源端口。
  noHostnames: (不能负载均衡到主机名)

formUserLabels:
  addAction: 添加标签
  key:
    label: 键
    placeholder: '例如:foo'
  separator: "="
  value:
    label: 值
    placeholder: '例如:bar'
  protip: "高级技巧: 粘贴一行或多行的 key=value键值对能够批量输入。"

formValueArray:
  addActionLabel: 添加值
  valueLabel: 值
  valuePlacholder: 值
  protip: "高级技巧: 在任意输入栏中粘贴一行或多行的 value能够批量输入。"

formVolumes:
  value:
    prompt: 选择容器...

heroAddService:
  header: 添加第一个服务
  paragraph1: |
    简单而言，服务是一组由相同docker镜像创建的容器，Rancher服务扩展了Docker的“link”概念以利用{appName}的轻量级分布式DNS服务用于服务发现。
    服务可以单独添加或通过应用商店部署。
  paragraph2: "服务也能够利用其他{appName}内置服务，如负载均衡、健康监控、升级支持以及高可用。"
  contentLink: 了解更多
  addService: 添加服务
  linkToCatalog: 从应用商店添加

hostSettings:
  header: 主机注册URL
  subtext: "主机连接{appName} API的Base URL是？"
  hostUrl:
    local: '当前站点地址:'
    new:
      labelText: '其他地址:'
      placeholder: "例如:http://example.com:8080"
  helpText:
    static1: "不要包含 <code>/v1</code> 或任何其他路径，但如果你设置了"
    static2: "在 {appName} 前面，请确保使用<code>https://</code>."
    isRancher: '<a href="{docsBase}/installing-rancher/installing-server/basic-ssl-config/" target="_blank">SSL Termination(SSL终止) </a>'
    sslTerm: SSL终止
  notPublic:
    alert: |
      确定要创建的所有主机都能够连接 <code>{activeValue}</code> ？<br/> 当前地址似乎是私有IP或内部网络。

hostPod:
  machineInfo:
    active:
      activating: |
        即将完成&hellip;<br/>
        <i class="icon icon-spinner icon-spin"></i> 等待客户端代理连接
    deactivated:
      error: 创建主机出错
      setup: 设置主机中...
    groupedInstances:
      namespace: '命名空间:'
      stack: '应用栈:'
      standalone: 独立容器

identityBlock:
  loading: 加载中...

infoMultiStats:
  connecting: 连接中...
  utilizationStats: 使用率统计数据仅在活动/运行时可见
  cpuSection:
    labelText: CPU
    system: 系统
    user: 用户
  networkSection:
    labelText: 网络
    transmit: 发送
    receive: 接收
  memorySection:
    labelText: 内存
    used: 已使用
  storageSection:
    labelText: 存储
    read: 读
    write: 写

inputCertificate:
  key:
    label: 私钥
    placeholder: "粘贴或导入私钥，以-----BEGIN RSA PRIVATE KEY-----开头"
  cert:
    label: 证书
    placeholder: "粘贴或导入证书，以-----BEGIN CERTIFICATE-----开头"
  certChain:
    label: 证书链
    placeholder: "可选:粘贴或导入额外的证书链，以-----BEGIN CERTIFICATE-----开头"

inputIdentity:
  placeholder:
    github: 添加GitHub用户或组织名称
    generic: 添加用户名或组名

inputPassword:
  buttonText: 生成

inputTextFile:
  tooltip: 从文件读取


k8s:
  servicePorts:
    port: 端口
    containerPort: 容器端口
    nodePort: Node端口
    protocol: 协议
    noPorts: 无端口
  containersSection:
    containerName: 容器名称
    status: 状态
    message: 消息
    ready: 就绪
    restarts: 重启
    noContainers: 无容器
  formContainerPorts:
    portMap: 端口映射
    addPort: 添加端口
    table:
      header:
        hostIp: 主机IP
        hostPort: 主机端口
        containerPort: 容器端口
        protocol: 协议
      body:
        name: '例如:web'
        hostIp: '例如:19.82.8.24'
        hostPort: '例如:80'
        containerPort: '例如:8080'
    noPorts: 此容器没有映射端口
  newOrEditResource:
    placeholder: 资源YAML或JSON定义
  podSection:
    podName: Pod名称
    containers: 容器
    status: 状态
    hostIp: 主机IP
    podIp: "Pod IP"
    noPods: 无Pods
  serviceRow:
    clusterIp: "Cluster IP"

lbAddtlInfo:
  viewDetails: 查看详情
  defaultCertificate: 缺省证书
  alternateCertificate: 替换证书
  description: "描述: "
  containers: 容器
  noContainers: 无容器
  scale: 数量
  ports: 端口
  noPorts: 无公开主机端口
  targets: 目标
  to: 到

labelsSection:
  kind: 类型
  key: 键
  value: 值
  noData: 无标签

loginGitHub:
  buttonText: GitHub验证

loginUserPass:
  userLabel: 用户名
  userPlaceholder: '例如:jsmith'
  loginLabel: 登录
  loggingInLabel: 登录中...
  passwordLabel: 密码

machine:
  driverAmazon:
    accessSection: 账户访问
    accessKey:
      label: "Access Key"
      placeholder: "你的AWS access key"
    secretKey:
      label: "Secret Key"
      placeholder: "你的AWS secret key"
      provided: 已提供
    accessKeyHelp: 在此粘贴你的AWS密钥对，我们将用秘钥创建新的实例。
    loginAction: '下一步:验证及选择网络'
    loadingAvailability: 从EC2加载可用区和VPC信息...
    vpcSection: "可用区 & VPC"
    availabilityZone: 可用区
    subnet: VPC/Subnet
    securityGroupSelect: '下一步:选择安全组'
    loadingSecurity: 从EC2加载安全组信息...
    securityGroupSection: 安全组
    securityGroup:
      label: 安全组
      defaultExisting: "标准:使用现有的 <code>{groupName}</code> 安全组"
      defaultCreate: "标准:自动创建新的 <code>{groupName}</code> 安全组"
      custom: '自定义:选择现有安全组'
      updating: 更新安全组...
      creating: 创建安全组...
    portHelp:
      link: 了解更多
      text: 关于将要开放的端口信息
    needs:
      label: '{appName} 正常工作需要安全组允许以下通讯:'
      item1: '从 {appName} 服务器到主机的 <code>TCP</code> 端口 <code>22</code> <span class="text-muted">(SSH连接以安置配置Docker)</span>'
      item2: 与其他所有主机之间的 <code>UDP</code> 端口 <code>500</code> 和 <code>4500</code> <span class="text-muted">(用于IPsec网络)</span></li>
      item3: 这些规则 <b>不会</b> 被自动添加
    setInstanceAction: '下一步:设置实例选项'
    instanceSection: 实例
    instanceOptionsSection: 实例选项
    instanceType:
      label: 实例类型
    rootSize:
      label: 根分区硬盘大小
      unit: GB
    ami:
      label: Amazon系统映像(AMI)
      placeholder: "Ubuntu AMI"
      rancherList: "RancherOS AMI列表"
    sshUser:
      label: SSH用户
      placeholder: '例如:ubuntu'
    iam:
      label: IAM配置文件
    privateIp:
      label: 私有IP
    onlyPrivate:
      label: 仅使用私有IP地址

  driverAzure:
    accountAccessSection: 账户访问
    username:
      label: 用户名
      placeholder: Azure账户用户名
    password:
      label: 密码
      placeholder: Azure账户密码
    subscriptionId:
      label: 订阅ID
      placeholder: Azure订阅ID
    subscriptionCert:
      label: 订阅证书
      placeholder: Azure订阅证书
    instanceSection: 实例
    image:
      label: 镜像
      placeholder: "Ubuntu 15.10 x64"
    size:
      label: 规格
    sshPort:
      label: SSH端口
      placeholder: '例如:22'
    dockerPort:
      label: Docker端口
      placeholder: '例如:2376'
    dockerSwarm:
      label: "Docker Swarm Master端口"
      placeholder: '例如:3376'
    publishSettingsFile:
      label: 发布配置
      placeholder: 发布配置文件
    regionSection: 区域
    region:
      label: 区域

  driverCustom:
    step1: '启动一台Linux机器并安装最新版本的 <a href="http://www.docker.com/" target="_blank">Docker</a> 。'
    step2: '确认安全组或防火墙允许以下通讯:'
    step2li: '与其他所有主机之间的 <code>UDP</code> 端口 <code>500</code> 和 <code>4500</code> <span class="text-muted">(用于IPsec网络)</span>'
    step3: "可选项: 在主机上增加标签"
    step4: "可选项:设置主机使用的Public IP。如果添加的是运行 <code>rancher/server</code> 容器的主机则必须设置此选项。"
    step5Copy: 将下列脚本拷贝到每一台主机上运行以注册
    generating: 生成注册URL...
    step5Close:
      part1: 点击下面的关闭按钮，新的主机注册后会显示在
      link: 主机
      part2: 页面。
    close: 关闭

  driverDigitalocean:
    accountSection: 账户访问
    accessToken:
      label: 访问令牌*
      placeholder: "你的DigitalOcean API访问令牌"
      help: |
        由<a href="https://cloud.digitalocean.com/settings/applications" target="_blank">Apps & API</a>
        页面获取的DigitalOcean个人访问令牌
    instanceSection: 实例
    image:
      label: 镜像
    size:
      label: 大小
    regionSection: 区域
    region:
      label: 区域
    optionsSection: 选项
    backups:
      label: 启用备份
    ipv6:
      label: 启用IPv6
    privateNetworking:
      label: 启用私有网络

  driverExoscale:
    accountSection: 账户访问
    apiKey:
      label: "API Key"
      placeholder: "你的Exoscale API Key"
    secretKey:
      label: "Secret Key"
      placeholder: "你的Exoscale secret key"
      provided: 已提供
    accountHelp: 在此粘贴你的Exoscale密钥对，我们将用秘钥创建新的实例。
    loginAction: 下一步:验证及选择安全组
    loadingSecurity: 从Exoscale加载安全组...
    securityGroupSection: 安全组
    securityGroup:
      label: 安全组
      defaultExisting: "标准:使用现有的 <code>{groupName}</code> 安全组"
      defaultCreate: "标准:自动创建 <code>{groupName}</code> 安全组"
      custom: '自定义:选择现有安全组'
      updating: 更新安全组...
      creating: 创建安全组...
    portHelp:
      link: 了解更多
      text: 關於將要開放的連接埠訊息
    needs:
      label: "{appName} 正常工作需要安全组允許以下通訊:"
      item1: '從 {appName} 伺服器到主機的 <code>TCP</code> 連接埠 <code>22</code> <span class="text-muted">(SSH連接以安裝設定Docker)</span>'
      item2: 與其他所有主機之間的 <code>UDP</code> 連接埠 <code>500</code> 和 <code>4500</code> <span class="text-muted">(用於IPsec網路)</span>
      item3: 這些規則 <b>不會</b> 被自動增加
    selectSecurityGroupAction: '下一步:设置实例选项'
    loadingInstance: 读取可用实例配置...
    instanceSection: 实例
    instanceProfile:
      label: 实例配置文件
    diskSize:
      label: Root大小


  driverOther:
    driverSection: 驱动
    driver:
      label: 驱动
    optionsSection: "{driverName} 选项"

  driverPacket:
    accountSection: 账户访问
    projectId:
      label: 项目
      placeholder: 你的Packet项目ID
    apiKey:
      label: "API Key"
      placeholder: "你的Packet API Key"
    apiKeyHelp: '由Packet的 <a href="https://app.packet.net/portal#/api-keys" target="_blank">API Keys</a> 页面获取'
    instanceSection: 实例
    image:
      label: 镜像
    size:
      label: 大小
    regionSection: 区域
    region:
      label: 区域

  driverRackspace:
    accountSection: 账户访问
    username:
      label: 用户名
      placeholder: 你的RackSpace用户名
    apiKey:
      label: "API Key"
      placeholder: "你的RackSpace APK Key"
    accountHelp: RackSpace控制面板中的帳號設定
    regionSection: 区域
    region:
      label: 区域
    instanceSection: 实例
    flavor:
      label: Flavor

  driverUbiquity:
    accountSection: 账户访问
    clientId:
      label: "Reseller ID"
      placeholder: "你的Ubiquity Hosting API Reseller ID"
    apiUsername:
      label: "Remote ID"
      placeholder: "你的Ubiquity Hosting API Reseller ID"
    apiToken:
      label: "Access Key"
      placeholder: "你的Ubiquity Hosting Access Key"
      provided: 已提供
    accountHelp: 你可以从 <a href="https://motion.ubiquityhosting.com/api"> 这里 </a>找到你的Ubiquity Hosting API密码。还没有账号？了解更多 <a href="http://www.ubiquityhosting.com/">Ubiquity Hosting</a> 信息！
    loginAction: '下一步:认证并创建一个Cloud实例'
    loadingInstance: 加载Cloud实例创建过程详细..
    instanceSection: 实例
    regionSection: 区域
    region:
      label: 区域
    image:
      label: 镜像
    flavor:
      label: Flavor

  driverVsphere:
    accountSection: 账户访问
    vcenter:
      label: "vCenter 主机"
      placeholder: vCenter或者ESXi主机名/IP
    vcenterPort:
      label: vCenter端口
    username:
      label: 用户名
    password:
      label: 密码
    instanceSection: 实例
    cpuCount:
      label: CPUs
    memorySize:
      label: 記憶體
      unit: MB
    diskSize:
      label: 磁碟
      unit: MB
    boot2dockerUrl:
      label: "OS ISO URL"
      placeholder: '缺省:最新的boot2docker镜像'
    schedulingSection: 计划
    dataCenter:
      label: 資料中心
    pool:
      label: 池
    host:
      label: 主機
      placeholder: 使用群集时输入"/"
    network:
      label: 網路
    dataStore:
      label: 數據儲存

modalAboutComponent:
  component: 元件
  version: 版本
  cattle: Cattle
  ui: 用户界面
  compose: Compose
  machineService: "Machine Service"
  docerkMachine: docker-machine
  close: 關閉

modalAuditlogInfo:
  header: 额外日志信息
  request: '請求對象:'
  response: '回應對象:'
  closer: 關閉

modalConfirmDeactiviate:
  header: 是否確認要
  protip: "高级技巧:在点击 {isServiceButton} 时按住 {alternateLabel}  键以跳过确认操作"
  cancel: 取消

modalEditDriver:
  header:
    create: "增加 Machine 驅動"
    edit: "編輯 Machine 驅動"
  url:
    label: 下载URL
    help: "64位Linux Docker-Machine驅動下載位址"
  uiUrl:
    label: "自定義UI URL"
    help: 可選:加載該驅動自定義增加主機介面的URL
    link: '參考 <a href="https://github.com/rancher/ui-driver-skel" target="_blank">ui-driver-skel</a> 以了解更多訊息。'
  checksum:
    label: 校驗
    help: "可選: 检验下载的驱动是否匹配期望的校验和"

modalProcessError:
  header: 異常訊息
  cause: '原因:'
  none: N/A
  stackTrace: '堆栈追蹤:'
  close: 關閉

modalShell:
  title: "命令行:{instanceName}"

newAliasService:
  header: 增加服務别名

newBalancer:
  header: 增加負載均衡
  note: |
    <p><strong>注意:</strong> 未匹配任何&quot;高级路由选项&quot;的请求将被发送到<strong>全部</strong> ({targetResources}) 配置的目标服务（轮询方式）的默认目标端口（根据请求的源端口确认）。</p>
  tabs:
    ssl: SSL终止
    stickiness: 会话粘性
    custom: 自定義haproxy.cfg
    labels: 標籤
    scheduling: 調度
  helpBlock: |
    <p class="help-block">此處可以設定其他 <a href="http://cbonte.github.io/haproxy-dconv/configuration-1.5.html" target="_blank">haproxy.cfg</a> 配置项，相关内容将被附加到 {appName} 生成的配置中。 </p>
  labelGlobal: <code>global</code> section
  labelDefault: <code>defaults</code> section


newCatalog:
  version:
    prompt: 選擇版本...
  saveUpgrade: 升级
  saveNew: 启动
  upgrade: '升级:'
  catalog: '应用商店:'
  category: '類別:'
  support: '支援:'
  official: 官方認證
  maintainedBy: 由社區成員維護
  maintainer: '維護者:'
  license: '授權:'
  url: '项目URL:'
  stack: 应用栈
  templateVersion: 範本版本
  selectVersion: 選擇一個範本版本
  newStack: 新应用栈
  config: 配置选项
  unknownType: '未識別問題類型:'
  startService: 创建后启动服务
  preview: 預覽
  txt: answers.txt

newContainer:
  service: |
    {numServices, plural,
      =1 {服務}
      other {服務}
    }
  tabs:
    disks: 磁碟
    userData: 用户資料
    command: 命令
    volumes: 卷
    networking: 網路
    security: 安全/主機
    healthCheck: 健康检查
    labels: 標籤
    scheduling: 調度
  selectUpgrade: 選擇一個或者多個服務進行升級
  saveUpgrade: 升级
  saveNew: 创建
  removeSidekick: 删除从容器
  name:
    placeholder: '例如:myapp'
  description:
    placeholder: '例如:我的應用'
  emptyPrimaryService: (主服务)
  emptySidekick: "(从容器 #{num})"
  addSidekickContainer: 添加从容器
  addSidekickVm: 添加从虚拟机

newExternalService:
  header: 添加外部服务
  alert: '注意:此设置仅当外部服务为负载均衡的目标服务时使用。'

pageFooter:
  notARelease: (非正式发布)
  help: 幫助
  documentation: 文件
  faq: 常見問題
  issues: 提交問題
  forums: 論壇
  download:
    link: 下載CLI
    mac: "Mac OS X"
    windows: Windows
    linux: Linux

pageHeaderEnvironment:
  namespace: 命名空间

projectRow:
  none: 無描述
  orchestration: 编排

registryRow:
  address: 位址
  email: 電子郵件
  username: 用户名
  created: 建立時間

schema:
  inputBoolean:
    y: "True"
    n: "False"
  inputCertificate:
    prompt: 選擇憑證...
  inputEnum:
    option: 選項...
  inputService:
    prompt: 選擇服務...

saveCancel:
  saving: 儲存中...
  saved: 已儲存！
  edit: 編輯
  create: 建立
  cancel: 取消

schedulingRuleRow:
  theHost: 主機
  haveA: 具有
  of: 其

sidekickAddtlInfo:
  info: 訊息
  image: 映像
  entryPoint: 入口
  command: 命令
  containers: 容器
  noContainers: 無容器
  labels: 標籤
  noLabels: 無標籤

stackSection:
  outputs: 输出
  description: 描述
  none: 無服務
  container: |
    {numContainers, plural,
      =1 {容器}
      other {容器}
    }
  service: |
    {numServices, plural,
      =1 {服務}
      other {服務}
    }
  sidekick: |
    {numSidekicks, plural,
      =1 {从容器}
      other {从容器}
    }
  add:
    service: 添加服务
    loadBalancer: 添加负载均衡
    serviceAlias: 添加服务别名
    externalService: 添加外部服务
    virtualMachine: 添加虚拟机
  table:
    dataTitle:
      state: 狀態
      serviceName: 服務名稱
      kind: 類型
      details: 查看詳情
      containers: 容器
      actions: 操作


storagePoolSection:
  outputs: 输出
  readOnly: (唯讀)
  hosts:
    header: 主机
    none: 无主机
  volumes:
    header: 卷
    add: 添加卷
    none: 无数据卷
  models:
    table:
      header:
        activeMounts: '挂载(容器:主机)'

svgServiceContainer:
  sidekicks: 从容器

swarm:
  containerSection:
    state: 狀態
    name: 容器名稱
    image: 映像
    none: 无容器
  serviceSection:
    state: 狀態
    name: 服務名稱
    ports: 連接埠
    containers: 容器
    none: 无服务

tooltipLink:
  list: 列表
  linkGraph: 链接图
  composeYaml: "Compose YAML"

tooltipWarning:
  notConfigured: 未设置访问控制
  dismiss: 取消

viewEditDescription:
  form:
    name:
      placeholder: '例如:lab'
    description:
      placeholder: '例如:開發測試環境'

viewEditProject:
  showEdit:
    edit: 編輯環境
    add: 增加環境
    orchestration: 容器编排
    formControl: 訪問控制
  header: 环境
  description: 描述
  helpBlock: |
    未启用访问控制。<br/>
    任何访问API/UI的人都具有管理员权限，并能够使用任何环境。
  virtualMachine:
    label: 虛擬機支援
    subtext: |
      要求主机加载 <a href="https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine" target="_blank">KVM</a> 内核模块


vmConsole:
  header: '控制台:'
  protip: "高级技巧:启动命令行时按下 {alternateLabel} 键可在新窗口中打开."
  canvas: 暫不提供Canvas支援
  footerActions:
    buttonSend: 发送Ctrl-Alt-Delete
    buttonCancel: 關閉

volumeRow:
  activeMounts:
    readOnly: （唯讀）
##############################
# Mixins
##############################
containerChoices:
  hostGroup: "主機:{name}"
  hostGroupWithState: "主機:{name}{state}"
  unknownHost: "主機:???"
  containerOption: "{name}"
  containerOptionWithState: "{name} ({state})"

driver:
  multiHostNames: "主機將被命名為 <b>{first}</b> &mdash; <b>{last}</b>"

##############################
# Services
##############################
allServices:
  stackGroup: "应用栈:{name}"
  noName: "(应用栈:{id})"

##############################
# Utils
##############################

##############################
# Navigation
##############################
nav:
  srToggleNav: 切换导航
  srToggleDropdown: 切换下拉選單
  environment:
    label: 環境
    all: 所有環境
    your: 你的環境
    selected: 當前環境
    manage: 環境管理
  namespace:
    label: 命名空间
    manage: 命名空间管理
  k8s:
    tab: Kubernets
    services: 服務
    rcs: "Replication Controllers"
    pods: Pods
    cli: Kubectl
    system: 系统
  swarm:
    tab: Swarm
    projects: 項目
    services: 服務
    cli: CLI
    system: 系统
  mesos:
    tab: Mesos
    web: 概览
    system: 系统
  cattle:
    tab: 应用栈
    all: 全部
    user: 用户
    system: 系统
  catalog:
    tab: 应用商店
    all: 全部
    library: Library
  infra:
    tab: 基礎架構
    hosts: 主機
    containers: 容器
    vms: 虛擬機
    storagePools: 存儲池
    certificates: 憑證
    registries: 映像庫
  admin:
    tab: 系统管理
    audit: 审计日志
    processes: 處理程序
    accounts: 帳號設定
    access: 存取控制
    machine: 主机驱动
    settings: 系統設定
    ha: 高可用
  api:
    tab: API
  user:
    label: "用戶選單:{username}"
    logout: 登出
    yourAccount: 你的帳號
    changePassword: 修改密码
    theme: 主题
    themeLight: 淺色
    themeAuto: 自動
    themeDark: 黑色

##############################
# Resource Actions
##############################
action:
  activate: 啟用
  cancelUpgrade: 取消升级
  cancelRollback: 取消回滚
  clone: 再製
  console: 打开控制台
  deactivate: 停用
  edit: 編輯
  execute: 执行命令行
  exportConfig: 匯出設定
  finishUpgrade: 升级完成
  logs: 查看日志
  machineConfig: 主機設定
  purge: 清除
  remove: 删除
  restart: 重啟
  restore: 恢復
  retry: 重試
  rollback: 回滚
  setDefault: 設定預設
  start: 啟動
  startServices: 啟動服務
  stop: 停止
  stopServices: 停止服務
  switchNamespace: 切换至此命名空间
  switchEnvironment: 切換到此環境
  upgrade: 升级
  viewConfig: 查看設定
  viewGraph: 查看圖解
  viewInApi: 查看API
